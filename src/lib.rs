// SPDX-License-Identifier: MPL-2.0
//
// Copyright Â© 2025 RemasteredArch
//
// This Source Code Form is subject to the terms of the Mozilla Public License, version 2.0. If a
// copy of the Mozilla Public License was not distributed with this file, You can obtain one at
// <https://mozilla.org/MPL/2.0/>.

use std::{
    collections::{BTreeSet, HashMap},
    fmt::Display,
    io::Write,
    str::FromStr,
};

use cargo_license::{DependencyDetails, GetDependenciesOpt};
use spdx::{ExceptionId, Expression, LicenseId};

/// A list of lowercase SPDX License Identifiers and the corresponding license texts, sorted by the
/// byte values of the lowercase SPDX License Identifiers.
///
/// Generated by `../data/harvest_licenses.sh`, which pulls them from
/// <https://github.com/github/choosealicense.com/tree/gh-pages/_licenses>.
const LICENSE_TEXTS: [(&str, &str); 47] = include!("../data/choosealicense.com_licenses.rs");

#[derive(Clone)]
pub struct Author {
    pub name: String,
    pub email: Option<String>,
}

impl Display for Author {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let formatted_email = if let Some(email) = &self.email {
            format!(" <{email}>")
        } else {
            String::new()
        };

        write!(f, "{}{formatted_email}", self.name)
    }
}

pub struct EmptyAuthorError;

impl FromStr for Author {
    type Err = EmptyAuthorError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(' ').collect::<Vec<_>>();

        if parts.is_empty() || (parts.len() == 1 && !parts.first().unwrap().is_empty()) {
            return Err(EmptyAuthorError);
        }

        let email =
            // Assume there has to at _least_ be a name before the email.
            if parts.len() > 1
                // An email address is always at the end of the entry and must be wrapped in angle
                // brackets.
                //
                // <https://github.com/rust-lang/cargo/blob/74544f1/src/doc/src/reference/manifest.md?plain=1#L121-L136>
                && parts.last().unwrap().starts_with('<')
                && parts.last().unwrap().ends_with('>')
            {
            Some(
                parts
                    .pop()
                    .unwrap()
                    .strip_prefix('<')
                    .unwrap()
                    .strip_suffix('>')
                    .unwrap()
                    .to_string()
            )
        } else {
            None
        };
        let name = parts.join(" ");

        Ok(Self { name, email })
    }
}

// Yes, this is unoptimized. No, I don't care right now.
fn escape_markdown(str: String) -> String {
    let mut out = String::new();
    for char in str.chars() {
        // CommonMark allows you to escape any ASCII punctuation. It's easier to be overly eager
        // than try to detect where it's absolutely necessary.
        //
        // <https://spec.commonmark.org/0.31.2/#backslash-escapes>
        if char.is_ascii_punctuation() {
            out.push('\\');
        }

        out.push(char);
    }
    out
}

#[derive(Clone)]
pub struct Crate {
    pub name: String,
    pub version: String,
    pub authors: Box<[Author]>,
    pub repository: String,
    pub license: Expression,
}

pub struct CrateMarkdown {
    pub name: String,
    pub version: String,
    pub authors: Box<[String]>,
    pub repository: String,
    pub license: String,
}

impl Crate {
    /// Creates a new [`Self`] with each field formatted into valid Markdown.
    ///
    /// For example, [`Self::name`] is wrapped in backticks and [`Self::repository`] is wrapped in
    /// angle brackets.
    ///
    /// Assumes that fields are well-formed, e.g., that [`Self::name`] is a valid crate name, that
    /// [`Author::email`] is a well-formed email for all authors in [`Self::authors`], that
    /// [`Self::repository`] is a well-formed URL, etc.
    pub fn into_markdown(self) -> CrateMarkdown {
        CrateMarkdown {
            // A Crate name shouldn't have backticks and nothing in backticks needs to be escaped
            // in CommonMark, so no escaping is needed here.
            name: format!("`{}`", self.name),
            // Probably excessive, but a particularly nasty SemVer version could probably have
            // something nasty, so I may as well escape it.
            version: escape_markdown(self.version),
            authors: self
                .authors
                .into_iter()
                .map(|mut author| {
                    // Assume that the email is well-formed. I don't care enough to be validating
                    // email right now!
                    author.name = escape_markdown(author.name);
                    author.to_string()
                })
                .collect(),
            repository: format!("<{}>", self.repository),
            // On brief investigation, I don't think an SPDX license expression should contain
            // backticks. Nothing in backticks needs to be escaped in CommonMark, so no escaping is
            // needed here.
            //
            // See:
            //
            // - <https://spdx.org/licenses/>
            // - <https://spdx.dev/wp-content/uploads/sites/31/2024/12/SPDX-3.0.1-1.pdf>
            license: format!("`{}`", self.license),
        }
    }
}

pub struct CrateList {
    list: Box<[Crate]>,
}

impl CrateList {
    /// Fetches the [`Crate`] information for direct and indirect dependencies of the crate at
    /// `directory_path`.
    pub fn from_crate_directory(directory_path: &str) -> Self {
        let mut cmd = cargo_metadata::MetadataCommand::new();
        // TO-DO: add some way to control features, platform, etc.?
        cmd.current_dir(directory_path);

        let opts = GetDependenciesOpt {
            // Don't include development dependencies for release builds, detected by whether debug
            // assertions are enabled.
            avoid_dev_deps: !cfg!(debug_assertions),
            avoid_build_deps: true,
            direct_deps_only: false,
            root_only: false,
        };

        let list = cargo_license::get_dependencies_from_cargo_lock(cmd, opts)
            .unwrap()
            .into_iter()
            .map(|dependency_details| {
                macro_rules! missing {
                    ($name:expr, $version:expr, $field:expr) => {
                        panic!(
                            "Received crate `{}` (version `{}`) without a listed {}",
                            $name, $version, $field
                        )
                    };
                }

                let DependencyDetails {
                    name,
                    version,
                    authors,
                    repository,
                    license,
                    ..
                } = dependency_details;

                Crate {
                    version: version.to_string(),
                    authors: authors
                        .unwrap_or_else(String::new)
                        .split('|')
                        .filter_map(|a| a.parse().ok())
                        .collect::<Box<[Author]>>(),
                    repository: repository.unwrap_or_else(|| missing!(name, version, "repository")),
                    license: license
                        .unwrap_or_else(|| missing!(name, version, "license"))
                        .parse()
                        .unwrap_or_else(|e: spdx::ParseError| match e.reason {
                            spdx::error::Reason::Empty => missing!(name, version, "license"),
                            _ => panic!("{e}"),
                        }),
                    // Out of order to allow the `missing!` errors to reference the crate name.
                    name,
                }
            })
            .collect();

        Self { list }
    }

    pub fn as_slice(&self) -> &[Crate] {
        self.list.as_ref()
    }

    pub fn by_license(&self) -> Box<[(usize, &Expression, Box<[&Crate]>)]> {
        fn increment_and_append_or_insert<'a>(
            map: &mut HashMap<&'a str, (usize, Vec<&'a Crate>)>,
            current_crate: &'a Crate,
        ) {
            let license: &str = current_crate.license.as_ref();
            match map.get_mut(license) {
                Some((current_count, crates)) => {
                    *current_count += 1;
                    crates.push(current_crate);
                }
                None => {
                    map.insert(license, (1, Vec::from([current_crate])));
                }
            };
        }

        let mut by_license: HashMap<&str, (usize, Vec<&Crate>)> = HashMap::new();
        for current_crate in self.list.iter() {
            increment_and_append_or_insert(&mut by_license, current_crate);
        }
        let mut vec = by_license
            .into_iter()
            .map(|(_, (count, crates))| (count, &crates[0].license, crates.into_boxed_slice()))
            .collect::<Vec<_>>();
        vec.sort_unstable_by(|(count_lhs, _, _), (count_rhs, _, _)| {
            count_lhs.cmp(count_rhs).reverse()
        });
        vec.into_boxed_slice()
    }

    pub fn to_markdown_license_page(&self, out: &mut impl Write) -> std::io::Result<()> {
        writeln!(out, "# Crate Licenses")?;
        let mut ids_to_print = BTreeSet::<LicensePart>::new();

        for (count, license_expression, crates) in self.by_license() {
            writeln!(
                out,
                "\n## `{license_expression}`\n\nUsed by {count} {}:\n",
                if count == 1 { "crate" } else { "crates" }
            )?;

            for CrateMarkdown {
                name,
                version,
                authors,
                repository,
                ..
            } in crates.iter().map(|&c| c.clone().into_markdown())
            {
                writeln!(out, "- {name} {version}\n  - Repository: {repository}")?;
                match authors.len() {
                    0 => (),
                    1 => {
                        writeln!(out, "  - Primary author: {}", authors[0])?;
                    }
                    _ => {
                        writeln!(out, "  - Primary authors:")?;
                        for author in authors {
                            writeln!(out, "    - {author}")?;
                        }
                    }
                }
            }

            for req in license_expression.requirements() {
                let spdx::LicenseReq {
                    license: license_item,
                    exception,
                } = &req.req;

                let license_id = match license_item {
                    spdx::LicenseItem::Spdx { id, .. } => id,
                    spdx::LicenseItem::Other { .. } => {
                        panic!("Received non-SPDX item in license `{license_expression}`")
                    }
                };

                ids_to_print.insert((*license_id).into());
                if let Some(exception_id) = exception {
                    ids_to_print.insert((*exception_id).into());
                }
            }
        }

        writeln!(out, "\n# License and Exception Full Texts")?;

        for id in ids_to_print {
            writeln!(
                out,
                "\n## {}\n\n```text\n{}```",
                escape_markdown(id.title()),
                id.text()
            )?;
        }

        Ok(())
    }
}

#[derive(PartialEq, Eq, PartialOrd, Ord)]
pub enum LicensePart {
    License(LicenseId),
    Exception(ExceptionId),
}

impl LicensePart {
    fn title(&self) -> String {
        match self {
            Self::License(license_id) => license_id.full_name.to_string(),
            Self::Exception(exception_id) => format!("`{}`", exception_id.name),
        }
    }

    /// It will first check if a license is present in
    /// [the licenses from `choosealicense.com`](https://github.com/github/choosealicense.com/tree/gh-pages/_licenses)
    /// (which provides hand-wrapped copies license texts), otherwise it will pull the text from
    /// [`spdx`] (which themselves are drawn from
    /// [SPDX's plain text license dumps](https://github.com/spdx/license-list-data/tree/main/text)).
    /// Only licenses and exceptions from the [SPDX License List](https://spdx.org/licenses) are
    /// supported.
    fn text(&self) -> &'static str {
        match self {
            Self::License(license_id) => {
                // Sorts by lowercase byte value, which should hopefully match that of
                // `harvest_licenses.sh`.
                LICENSE_TEXTS
                    .binary_search_by_key(&license_id.name.to_lowercase().as_str(), |(id, _)| id)
                    .map_or_else(|_| license_id.text(), |index| LICENSE_TEXTS[index].1)
            }
            Self::Exception(exception_id) => exception_id.text(),
        }
    }
}

impl From<LicenseId> for LicensePart {
    fn from(value: LicenseId) -> Self {
        Self::License(value)
    }
}

impl From<ExceptionId> for LicensePart {
    fn from(value: ExceptionId) -> Self {
        Self::Exception(value)
    }
}
